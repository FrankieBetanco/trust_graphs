\documentclass{article}

\title{Programming Assignment 1}
\author{Frankie Betancourt}

\begin{document}
\maketitle

\section{Introduction}
Two different programs were created for this programming assignment: an input
generator, and a graph generator. Both are written in C++, and are designed
to allow for a variety of attributes to be parsed, stored, and represented 
in graphs. 

\section{Input Format}
The input format is in csv format, with 11 columns: 
First Name, Last Name, Age, Gender, Language, ID, Email, Services, Groups,
Permissions for privacy, Permissions for anonymity. The first 9 columns are the
attributes of the user, and the last two are the representations of the users 
PPAI permissions. 

To represent the permissions for privacy and anonymity, I have chosen to 
represent the users choice as a number. Viewing the number in binary, the 
\(n^{th}\) bit in the number represents the \(n^{th}\) user attribute. A value 
of 1 for the bit indicates that they want to have an edge of the type of 
that attribute beginning at the current user, and terminating at all other
users. For example, if the permissions for privacy are set to "119", then 
it would translate to binary number 001110111, indicating that their first and
last name, ID are private, and the remaining attributes are public. 

This representation allows for a single adjacency matrix to be kept in memory 
at one time, and if a specific edge type is needed, one only needs to check if 
the bit for that attribute is set.

\section{Output} 
The output graphs are output as adjacency matrices on a per attribute bases. 
The reason adjacency matrices were chosen because it is assumed that the graphs
to be represented will be relatively dense, which means that little space will
be wasted. It was also chosen for its ease of use. 

The program prints out square matrices, with the elements in the matrix 
representing an edge from node \(i\) to node \(j\) if \(A_{i,j} = 1\) 
and no edge if \(A_{i,j} = 0\).

\section{Building}
Submitted is a tarfile containing the repository. After untarring, simply 
change directory to "src", and run "make". This should make both executables.
The subdirectories src/graph\_generator and src/input\_generator contain
the executables. For convienence, pre-made input files are included in 
src/graph\_generator/input\_files.

\section{Program: input\_gen}
The program "input\_gen" simply generates a list of users with random 
attributes and random PPAI permissions set. Since there are 9 attributes to
assign permissions to, the privacy permissions are assigned by choosing a
number between 0 and \(2^9\). To choose permissions for anonymity, the
bitwise complement of the privacy permissions was chosen to prevent collisions
between privacy and anonymity for an attribute. As for the other attributes, 
they were simply chosen randomly from lists for each user.

\subsection{Usage}
Usage of the input generator is simple: just specify the number of random user
to generate as an argument, e.g.
\begin{verbatim}
./input_gen 10
\end{verbatim}
will generate 10 random users.

\section{Program: graph\_gen}
The graph\_gen takes as input the output generated by input\_generator.
After parsing the input, the privacy graph and anonymity graph is constructed.
n-by-n matrix for n users read in. Each row in the matrix represents a user, 
and the row is filled up with the users desired permission number as described
before. 

\subsection{Usage}
To print an adjacency matrix for a given attribute, specify as follows: 
\begin{verbatim}
./graph_gen [filename] p [attribute num]
\end{verbatim}
The command will print matrices for the privacy and anonymity graphs for
the given attribute.\\

\noindent
To print the group membership graph, use the following: 
\begin{verbatim}
./graph_gen [filename] g
\end{verbatim}
and an adjacency matrix will be printed for group membership for all the users.
\end{document}
